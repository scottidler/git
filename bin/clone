#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import re
import sys
import argparse
import importlib

sys.dont_write_bytecode = True

from configparser import ConfigParser
from pprint import pprint
from subprocess import CalledProcessError

DIR = os.path.abspath(os.path.dirname(__file__) + "/..")
CWD = os.path.abspath(os.getcwd())
REL = os.path.relpath(DIR, CWD)
GIT_PY = f'{DIR}/git.py'
GIT_PY2 = '/home/sidler/.../repos/scottidler/git/git.py'
git = importlib.machinery.SourceFileLoader('git', GIT_PY).load_module()
CONFIGS = [
    '~/.config/clone/clone.cfg',
    f'{DIR}/cfg/clone.cfg',
]

class FailedDiscover(Exception):
    def __init__(self, repospec, remotes):
        message = ' '.join([remote + repospec for remote in remotes])
        super(FailedDiscover, self).__init__(message)

def load_config(filenames):
    for filename in filenames:
        filename = os.path.abspath(os.path.expanduser(filename))
        parser = ConfigParser()
        cfg = {}
        if os.path.isfile(filename):
            parser.read(filename)
            for name, value in parser.items('clone'):
                if '\n' in value:
                    value = value.strip().split('\n')
                cfg[name] = value
            orgs = {}
            for section in parser.sections():
                if section.startswith('org.'):
                    orgs[section[len('org.'):]] = {
                        'urlsuffix': parser[section].get('urlsuffix', None),
                        'username': parser[section].get('username', None),
                        'useremail': parser[section].get('useremail', None),
                    }
            cfg['orgs'] = orgs
            return cfg

def decompose(remote, repospec, verbose=False):
    pattern = '((git|ssh|https?|rsync)://)(\w+@)?([\w\.]+)(:(\d+))?[:/]{1,2}'
    regex = re.compile(pattern)
    if remote:
        return remote, repospec
    match = regex.match(repospec)
    if match:
        remote = match.group()
        reponame = os.path.splitext(repospec[len(remote):])[0]
    else:
        reponame = repospec
    if verbose:
        print(f'decompose: remote={remote} reponame={reponame}')
    return remote, reponame

def discover(remotes, repospec, verbose=False):
    if verbose:
        print('repospec =', repospec)
    for remote in remotes:
        if verbose:
            print('remote =', remote)
        repourl = os.path.join(remote, repospec)
        exitcode, stdout, stderr = git.ls_remote(repourl, verbose=verbose)
        if 0 == exitcode:
            return decompose(remote, repospec)
    raise FailedDiscover(repospec, remotes)

def divine(reponame, cfg):
    project = os.path.dirname(reponame)
    default = cfg['orgs'].get('default', {})
    org = cfg['orgs'].get(project, {})
    urlsuffix = org.get('urlsuffix', default.get('urlsuffix', None))
    username = org.get('username', default.get('username', None))
    useremail = org.get('useremail', default.get('useremail', None))
    return urlsuffix, username, useremail

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--configs',
        metavar='FILE',
        default=CONFIGS,
        nargs='+',
        help='default="%(default)s"; list of configs to try; loads first found')
    parser.add_argument(
        '--remote',
        metavar='URL',
        help='the git url to be used with git clone')
    parser.add_argument(
        '--clonepath',
        metavar='PATH',
        default=os.getcwd(),
        help='path to store all cloned repos')
    parser.add_argument(
        '--mirrorpath',
        metavar='PATH',
        help='path to cached repos to support fast cloning')
    parser.add_argument(
        '--versioning',
        action='store_true',
        help='turn on versioning; checkout in reponame/commit rather than reponame')
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='turn on verbose output')
    parser.add_argument(
        'repospec',
        help='repospec schema is remote?reponame')
    parser.add_argument(
        'revision',
        default='master',
        nargs='?',
        help='revision')

    ns = parser.parse_args()
    locals().update(ns.__dict__)
    cfg = load_config(configs)
    remote, reponame = discover(cfg.get('remotes', [])+[''], repospec, verbose)
    urlsuffix, username, useremail = divine(reponame, cfg)
    if urlsuffix:
        remote += '-'+ urlsuffix
    print(
        git.clone(
            remote,
            reponame,
            revision,
            clonepath,
            mirrorpath,
            username,
            useremail,
            versioning))
